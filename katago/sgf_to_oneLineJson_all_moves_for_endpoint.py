from sgfmill import sgf
import json

# Converts a SGF into a single line JSON dictionary to feed into the Katago analysis engine on the command line
# NOTE: the convert_coord function takes in a tuple of INTEGERS, not letters.


def sgf_to_one_line_json(sgf_data):

    sgf_game = sgf.Sgf_game.from_string(sgf_data)

    root_node = sgf_game.get_root()

    # Extract relevant properties from SGF
    try:
      size = sgf_game.get_size()
      # if no size property found in SGF, throw an error with a message!
    except ValueError:
      print("Invalid SGF, size of board unknown!")

    komi = root_node.get('KM') if root_node.has_property('KM') else 0.5
    rules = root_node.get('RU').lower() if root_node.has_property('RU') else "?"
    # Need to make sure that if there's no AB or AW property (like in an even game) that there's no error
    # *** This must be converting the stones into integer coordinates instead of using sgf letter coordinates
    black_stones = root_node.get(
        'AB') if root_node.has_property('AB') else None
    white_stones = root_node.get(
        'AW') if root_node.has_property('AW') else None

    # Convert coordinates to KataGo 1 line JSON dictionary format
    # coord will be a tuple of INTEGERS, not letters!
    def convert_coord(coord):
        x, y = coord
        col = chr(ord('A') + y)
        if col >= 'I':
            col = chr(ord(col) + 1)
        row = x + 1
        return col + str(row)

    # Create initial stones list
    initial_stones = []
    if black_stones:
        for stone in black_stones:
            initial_stones.append(['B', convert_coord(stone)])
    if white_stones:
        for stone in white_stones:
            initial_stones.append(['W', convert_coord(stone)])

    # Create moves list
    moves = []
    main_sequence = sgf_game.get_main_sequence()
    for node in main_sequence:
        if node.has_property('B'):
            # Move is in integer tuple format, like this: (15, 16), (13, 0) (15, 18)
            move = node.get('B')
            if move is not None:
                # print("move: ", move)
                moves.append(['B', convert_coord(move)])
        elif node.has_property('W'):
            move = node.get('W')
            if move is not None:
                moves.append(['W', convert_coord(move)])

    # Create analyzeTurns list (off by one error unless we add the + 1 here since we start at move 0 and not 1)
    analyzeTurns = list(range(len(moves) + 1))

    # next_player is set to None if there is no move order to the game, AND the player's turn isn't specified
    next_player = None
    next_player_detected = False

    # If there's no move order and there's also a PL property, set player_turn (black or white) to that value (override above default value)
    if root_node.has_property('PL') and not moves:
        next_player = root_node.get('PL')
        next_player_detected = True

    elif moves:
        last_move = moves[-1]
        next_player = 'B' if last_move == 'W' else 'W'
        next_player_detected = True

    if not next_player_detected:
      next_player = input("Select next player, please input B for black and W for white: ")

    # Set komi in JSON dictionary
    if komi and float(komi) > 100:
        komi = 7.5
    # Fox games sometimes take the komi and sets it to 0.25, which shows up as 0.0 in the SGF
    # Also when forking from a puzzle or downloading it without the moves, it will set the komi to 0.0
    elif 0 <= float(komi) < 0.5:
        komi = 0.5
    else:
        komi = float(komi)

    # Create JSON dictionary
    result = {
        "id": 'sgfTest3',
        "rules": rules,
        "komi": komi,
        "boardXSize": size,
        "boardYSize": size,
        # Json formatting below automatically converts initialPlayer to a capital B/W instead of a lowercase B/W
        "initialPlayer": next_player,
        # We need analyzeTurns to be set to an empty list with the move 0 in it to analyze positions with no move property
        "analyzeTurns": analyzeTurns or [0],
        "initialStones": initial_stones,
        "moves": moves
    }
    # Convert dictionary to JSON-formatted string -> double quotes around property name is crucial, otherwise KataGo throws a syntax error
    result_json_format = json.dumps(result)

    return result_json_format

# ******* TESTING LOCALLY ********* #

one_line_output = sgf_to_one_line_json("(;GM[1]FF[4]CA[UTF-8]AP[CGoban:3]ST[2] RU[Chinese]SZ[19]KM[7.50]TM[300] GN[]PW[青瓦楼阁]PB[anning97]DT[2023-07-09]C[SGF generated by KaTrain 1.12.3ㅤ​]RE[B+Resign]KTV[1.0]RL[0]RN[3]TC[3]TT[30] ;B[qd] ;W[dp] ;B[pq] ;W[dd] ;B[cc] ;W[dc] ;B[cd] ;W[ce] ;B[be] ;W[bf] ;B[cf] ;W[de] ;B[bg] ;W[bd] ;B[af] ;W[bc] ;B[nc] ;W[qo] ;B[ql] ;W[op] ;B[oq] ;W[np] ;B[mr] ;W[lq] ;B[mq] ;W[mp] ;B[lp] ;W[kq] ;B[lo] ;W[rq] ;B[qr]C[Move 31: B R2 Score: W+3.9 Win rate: W 71.1% Estimated point loss: 4.3 Predicted top move was S2 (B+0.5). PV: BS2 K4 O6 P6 P7 O7 Q6 P5 P8 R3 R2 M6 Move was #96 according to policy (0.00%). Top policy move was K4 (40.0%). ㅤ​] ;W[rr] ;B[lr] ;W[kr] ;B[nq]C[Move 35: B O3 Score: W+8.9 Win rate: W 87.0% Estimated point loss: 4.4 Predicted top move was J4 (W+4.2). PV: BJ4 K4 K5 J3 H4 H3 G3 G4 G2 J5 H5 L5 J6 M6 N5 L4 Move was #33 according to policy (0.03%). Top policy move was J4 (29.8%). ㅤ​] ;W[on] ;B[jp] ;W[iq] ;B[ip] ;W[hq] ;B[go] ;W[fp] ;B[ol] ;W[nm] ;B[mk] ;W[rd] ;B[re] ;W[qc] ;B[rc] ;W[pd] ;B[qe] ;W[rb] ;B[sd] ;W[pe] ;B[pc] ;W[oc] ;B[qb] ;W[nd] ;B[ob] ;W[od]C[Move 60: W P16 Score: W+5.4 Win rate: W 78.3% Estimated point loss: 4.8 Predicted top move was M7 (W+10.4). PV: WM7 K7 L8 K8 L9 K9 L10 N12 Move was #134 according to policy (0.01%). Top policy move was M7 (32.0%). ㅤ​] ;B[mc] ;W[md] ;B[ld] ;W[le] ;B[ke] ;W[kf]C[Move 66: W L14 Score: W+0.5 Win rate: W 55.3% Estimated point loss: 5.4 Predicted top move was M14 (W+6.0). PV: WM14 F5 E5 L14 M13 P13 L13 L16 M7 K7 L9 Move was #3 according to policy (1.72%). Top policy move was M14 (75.8%). ㅤ​] ;B[kd])")

print(one_line_output)
